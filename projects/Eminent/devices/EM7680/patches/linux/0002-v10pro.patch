From 165ef8a8d44bffa2b774a51c3f1bd702d41225fb Mon Sep 17 00:00:00 2001
From: alex <surkov.alex@gmail.com>
Date: Sat, 23 Feb 2019 20:53:57 +0300
Subject: [PATCH] v10pro

---
 arch/arm64/boot/dts/amlogic/gxl_p212_2g.dts  |  39 +-
 drivers/amlogic/Kconfig                      |   3 +
 drivers/amlogic/Makefile                     |   3 +
 drivers/amlogic/input/gpio_key/aml_gpiokey.c |  79 ++++-
 drivers/amlogic/input/remote/remote_main.c   |  32 ++
 drivers/amlogic/ledlight/Kconfig             |   7 +
 drivers/amlogic/ledlight/Makefile            |   8 +
 drivers/amlogic/ledlight/ledlight.c          | 512 +++++++++++++++++++++++++++
 8 files changed, 677 insertions(+), 6 deletions(-)
 create mode 100644 drivers/amlogic/ledlight/Kconfig
 create mode 100644 drivers/amlogic/ledlight/Makefile
 create mode 100644 drivers/amlogic/ledlight/ledlight.c

diff --git a/arch/arm64/boot/dts/amlogic/gxl_p212_1g.dts b/arch/arm64/boot/dts/amlogic/gxl_p212_1g.dts
index c2cf7b8..e3c4fc8 100644
--- a/arch/arm64/boot/dts/amlogic/gxl_p212_1g.dts
+++ b/arch/arm64/boot/dts/amlogic/gxl_p212_1g.dts
@@ -137,13 +137,14 @@
 
 	};
 
-	sysled {
+	/*by luobx*/
+	/*sysled {
 		compatible = "amlogic, sysled";
 		dev_name = "sysled";
 		status = "okay";
 		led_gpio = <&gpio GPIODV_24 GPIO_ACTIVE_HIGH>;
 		led_active_low = <1>;
-	};
+	};*/
 
 	meson-vout {
 		compatible = "amlogic, meson-vout";
@@ -1188,6 +1189,40 @@
 			};
 		};
 	};
+		/*add by luobx*/
+	  ledlight{
+    compatible = "amlogic, ledlight";
+    dev_name = "ledlight";
+    status = "okay";
+	power_gpio_0 = <&power_gpio_0>;
+	power_gpio_1 = <&power_gpio_1>;
+    power_gpio_0: power_gpio_g{
+      led_name = "power_led";
+      led_gpio = <&gpio  GPIODV_24  GPIO_ACTIVE_HIGH>;
+      led_active = <1>;
+      led_type = "G";
+    };
+	power_gpio_1: power_gpio_r{
+      led_name = "power_led";
+      led_gpio = <&gpio_ao  GPIOAO_6  GPIO_ACTIVE_HIGH>;
+      led_active = <1>;
+      led_type = "R";
+    };
+/*  
+    net_gpio_0: gpio_r{
+        led_name = "net_led";
+        led_gpio = <&gpio_ao  GPIOAO_3  GPIO_ACTIVE_HIGH>;
+        led_active = <1>;
+        led_type = "R";
+    };
+    net_gpio_1: gpio_g{
+        led_name = "net_led";
+        led_gpio = <&gpio_ao  GPIOAO_9  GPIO_ACTIVE_HIGH>;
+        led_active = <1>;
+        led_type = "G";
+    };
+    */
+  };
 };
 
 &pinmux {
diff --git a/arch/arm64/boot/dts/amlogic/gxl_p212_2g.dts b/arch/arm64/boot/dts/amlogic/gxl_p212_2g.dts
index c2cf7b8..e3c4fc8 100644
--- a/arch/arm64/boot/dts/amlogic/gxl_p212_2g.dts
+++ b/arch/arm64/boot/dts/amlogic/gxl_p212_2g.dts
@@ -137,13 +137,14 @@
 
 	};
 
-	sysled {
+	/*by luobx*/
+	/*sysled {
 		compatible = "amlogic, sysled";
 		dev_name = "sysled";
 		status = "okay";
 		led_gpio = <&gpio GPIODV_24 GPIO_ACTIVE_HIGH>;
 		led_active_low = <1>;
-	};
+	};*/
 
 	meson-vout {
 		compatible = "amlogic, meson-vout";
@@ -1188,6 +1189,40 @@
 			};
 		};
 	};
+		/*add by luobx*/
+	  ledlight{
+    compatible = "amlogic, ledlight";
+    dev_name = "ledlight";
+    status = "okay";
+	power_gpio_0 = <&power_gpio_0>;
+	power_gpio_1 = <&power_gpio_1>;
+    power_gpio_0: power_gpio_g{
+      led_name = "power_led";
+      led_gpio = <&gpio  GPIODV_24  GPIO_ACTIVE_HIGH>;
+      led_active = <1>;
+      led_type = "G";
+    };
+	power_gpio_1: power_gpio_r{
+      led_name = "power_led";
+      led_gpio = <&gpio_ao  GPIOAO_6  GPIO_ACTIVE_HIGH>;
+      led_active = <1>;
+      led_type = "R";
+    };
+/*  
+    net_gpio_0: gpio_r{
+        led_name = "net_led";
+        led_gpio = <&gpio_ao  GPIOAO_3  GPIO_ACTIVE_HIGH>;
+        led_active = <1>;
+        led_type = "R";
+    };
+    net_gpio_1: gpio_g{
+        led_name = "net_led";
+        led_gpio = <&gpio_ao  GPIOAO_9  GPIO_ACTIVE_HIGH>;
+        led_active = <1>;
+        led_type = "G";
+    };
+    */
+  };
 };
 
 &pinmux {
diff --git a/drivers/amlogic/Kconfig b/drivers/amlogic/Kconfig
index bbe4555..6c43610 100644
--- a/drivers/amlogic/Kconfig
+++ b/drivers/amlogic/Kconfig
@@ -132,4 +132,7 @@ source "drivers/amlogic/crypto/Kconfig"
 source "drivers/amlogic/watchpoint/Kconfig"
 
 source "drivers/amlogic/esm/Kconfig"
+
+source "drivers/amlogic/ledlight/Kconfig"
+
 endmenu
diff --git a/drivers/amlogic/Makefile b/drivers/amlogic/Makefile
index 986403d..288f04d 100644
--- a/drivers/amlogic/Makefile
+++ b/drivers/amlogic/Makefile
@@ -138,3 +138,6 @@ obj-$(CONFIG_CRYPTO_AML)	+= crypto/
 
 obj-$(CONFIG_AMLOGIC_WATCHPOINT) += watchpoint/
 obj-$(CONFIG_AML_ESM) += esm/
+
+#by luobx
+obj-$(CONFIG_AMLOGIC_LEDLIGHT) += ledlight/
\ No newline at end of file
diff --git a/drivers/amlogic/input/gpio_key/aml_gpiokey.c b/drivers/amlogic/input/gpio_key/aml_gpiokey.c
index 1c87357..8933c11 100644
--- a/drivers/amlogic/input/gpio_key/aml_gpiokey.c
+++ b/drivers/amlogic/input/gpio_key/aml_gpiokey.c
@@ -55,6 +55,11 @@
 
 #define MOD_NAME       "gpio_key"
 /*#define USE_IRQ     */
+//by luobx for reset
+#define RESETKEY_DEVICE_NAME        "resetkey"
+#define MEMDEV_NR_DEVS 1
+static int RESETVALUE = -1;
+dev_t devResetNo = 0;
 
 struct gpio_key {
 	int code;	  /* input key code */
@@ -90,6 +95,46 @@ struct kp {
 
 static struct kp *gp_kp;
 
+//by luobx for reset
+static ssize_t resetkey_show(struct class *cla,
+        struct class_attribute *attr, char *buf)
+{
+    ssize_t ret = 0;
+
+    sprintf(buf, "%#x\n", RESETVALUE);
+    
+    ret = strlen(buf) + 1;
+    //printk("ret = %d\n", ret);
+    //printk("RESETVALUE = %d\n", RESETVALUE);
+
+    return ret;
+
+}
+
+static ssize_t resetkey_store(struct class *cla,
+        struct class_attribute *attr,
+        const char *buf, size_t count)
+{
+	      ssize_t ret = 0;
+        sscanf(buf, "%d\n", &RESETVALUE);  
+        printk("RESETVALUE = %d\n", RESETVALUE);
+        ret = strlen(buf) + 1;
+        return ret; 
+}
+
+static struct class_attribute resetkey_class_attrs[] = {
+   __ATTR(count, S_IRUGO|S_IWUSR|S_IWGRP, resetkey_show, resetkey_store),
+	__ATTR_NULL
+
+};
+static struct class resetkey_class = {
+    
+	.name = RESETKEY_DEVICE_NAME,
+    
+	.class_attrs = resetkey_class_attrs,
+
+};
+
 int amlogic_gpio_name_map_num(struct platform_device *pdev , const char *value)
 {
 	return of_property_read_string(pdev->dev.of_node, "key_pin" ,  &value);
@@ -107,16 +152,18 @@ static void kp_work(struct kp *kp)
 		/*dev_info(&kp->input->dev, "get gpio key status %s(%d)\n",
 			 key->name ,  io_status);*/
 		if (io_status != key->status) {
+			//by luobx for reset
 			if (io_status) {
 				dev_info(&kp->input->dev,
 					 "key %d up\n", key->code);
-				input_report_key(kp->input ,  key->code , 0);
-				input_sync(kp->input);
+				//input_report_key(kp->input ,  key->code , 0);
+				//input_sync(kp->input);
 			} else {
 				dev_info(&kp->input->dev,
 					 "key %d down\n", key->code);
-				input_report_key(kp->input , key->code , 1);
-				input_sync(kp->input);
+				//input_report_key(kp->input , key->code , 1);
+				//input_sync(kp->input);
+				RESETVALUE++;
 			}
 			key->status = io_status;
 		}
@@ -230,6 +277,28 @@ static int gpio_key_probe(struct platform_device *pdev)
 
 	int gpio_highz = 0;
 
+	//by luobx for reset
+		ret = alloc_chrdev_region(&devResetNo, 0, MEMDEV_NR_DEVS, RESETKEY_DEVICE_NAME);
+    if(ret < 0)
+    {
+        printk (KERN_ERR "Error %d alloc and region char cdev", ret);
+        return ret;
+    }	
+    
+		/* creating your own class */
+    ret = class_register(&resetkey_class);
+    if(ret) {
+        printk("Err: failed in creating class.\n");
+        //goto err2;
+    }
+
+    /* register your own device in sysfs, and this will cause udevd to create corresponding device node */
+    if(NULL == device_create(&resetkey_class,NULL, devResetNo, NULL,RESETKEY_DEVICE_NAME))
+    {
+        printk("Err: failed in device_create.\n");
+        //goto err3; 
+    }
+    
 	if (!pdev->dev.of_node) {
 		dev_info(&pdev->dev, "gpio_key: pdev->dev.of_node == NULL!\n");
 		state = -EINVAL;
@@ -430,6 +499,8 @@ static int gpio_key_remove(struct platform_device *pdev)
 	struct gpio_platform_data *pdata = platform_get_drvdata(pdev);
 	struct kp *kp = gp_kp;
 
+	//by luobx for reset
+	device_destroy(&resetkey_class, devResetNo);
 	input_unregister_device(kp->input);
 	input_free_device(kp->input);
 	unregister_chrdev(kp->config_major ,  kp->config_name);
diff --git a/drivers/amlogic/input/remote/remote_main.c b/drivers/amlogic/input/remote/remote_main.c
index a004fa7..1767394 100644
--- a/drivers/amlogic/input/remote/remote_main.c
+++ b/drivers/amlogic/input/remote/remote_main.c
@@ -71,6 +71,11 @@ char *remote_log_buf;
 /* use 20 map for this driver*/
 static __u16 key_map[20][512];
 
+//by luobx
+#ifdef CONFIG_AMLOGIC_LEDLIGHT
+extern int set_remote_leds(int state);
+#endif
+
 #ifdef REMOTE_FIQ
 static  irqreturn_t (*remote_bridge_sw_isr[])(int irq, void *dev_id) = {
 	remote_null_bridge_isr,
@@ -227,6 +232,10 @@ static int remote_mouse_event(struct input_dev *dev, unsigned int scancode,
 void remote_send_key(struct input_dev *dev, unsigned int scancode,
 		     unsigned int type, int event)
 {
+	//by luobx
+	#ifdef CONFIG_AMLOGIC_LEDLIGHT
+	static int swith_led =1;
+	#endif
 	if (scancode == FN_KEY_SCANCODE && type == 1) {
 		/* switch from key to pointer*/
 		if (key_pointer_switch) {
@@ -286,6 +295,11 @@ void remote_send_key(struct input_dev *dev, unsigned int scancode,
 					key_map[gp_remote->map_num][scancode],
 					gp_remote->map_num,
 					gp_remote->cur_lsbkeycode);
+			//by luobx
+			#ifdef CONFIG_AMLOGIC_LEDLIGHT
+			set_remote_leds(1);
+			swith_led =1;
+			#endif
 			break;
 		case 1:
 			input_dbg("press ircode = 0x%02x,",
@@ -294,6 +308,11 @@ void remote_send_key(struct input_dev *dev, unsigned int scancode,
 					key_map[gp_remote->map_num][scancode],
 					gp_remote->map_num,
 					gp_remote->cur_lsbkeycode);
+			//by luobx
+			#ifdef CONFIG_AMLOGIC_LEDLIGHT
+			set_remote_leds(0);
+			swith_led =0;
+			#endif
 			break;
 		case 2:
 			input_dbg("repeat ircode = 0x%02x,",
@@ -302,6 +321,19 @@ void remote_send_key(struct input_dev *dev, unsigned int scancode,
 					key_map[gp_remote->map_num][scancode],
 					gp_remote->map_num,
 					gp_remote->cur_lsbkeycode);
+			//by luobx
+			#ifdef CONFIG_AMLOGIC_LEDLIGHT
+			if(swith_led ==1)
+			{
+					swith_led =0;
+					set_remote_leds(0);
+			}
+			else
+			{
+					swith_led =1;
+					set_remote_leds(1);
+			}
+			#endif
 			break;
 		}
 		if (gp_remote->sleep && scancode == 0x1a &&
diff --git a/drivers/amlogic/ledlight/Kconfig b/drivers/amlogic/ledlight/Kconfig
new file mode 100644
index 0000000..62b115b
--- /dev/null
+++ b/drivers/amlogic/ledlight/Kconfig
@@ -0,0 +1,7 @@
+#support amlogic external module power control
+
+menuconfig AMLOGIC_LEDLIGHT
+	tristate "Amlogic Led Light"
+	default n
+	help
+	  Amlogic Led Light
diff --git a/drivers/amlogic/ledlight/Makefile b/drivers/amlogic/ledlight/Makefile
new file mode 100644
index 0000000..25eab70
--- /dev/null
+++ b/drivers/amlogic/ledlight/Makefile
@@ -0,0 +1,8 @@
+#
+# Makefile for the input core drivers.
+#
+
+# Each configuration option enables a list of files.
+obj-$(CONFIG_AMLOGIC_LEDLIGHT)		+= ledlight.o
+
+
diff --git a/drivers/amlogic/ledlight/ledlight.c b/drivers/amlogic/ledlight/ledlight.c
new file mode 100644
index 0000000..17698f9
--- /dev/null
+++ b/drivers/amlogic/ledlight/ledlight.c
@@ -0,0 +1,512 @@
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/leds.h>
+#include <linux/gpio.h>
+#include <linux/proc_fs.h>
+#include <linux/printk.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+static struct early_suspend ledlight_early_suspend;
+#endif
+
+#define DRIVER_NAME "ledlight"
+
+#define DRV_NAME	DRIVER_NAME
+#define DRV_VERSION	"v3.0.0"
+
+enum ledlight_type {
+	LED_UNKNOWN = 0,
+	LED_NET = 1,
+	LED_POWER = 2,
+};
+
+enum led_type {
+	LED_RG = 0, /* double color led, Red and Green(R&G) */
+	LED_R = 1,  /* single color led, Red(R) */
+	LED_G = 2,  /* single color led, Green(G) */
+};
+
+enum led_state {
+	STATE_UNKNOWN  = 0,
+	STATE_OFF = 1,       /* open red led or close red&green led */
+	STATE_ON = 2,        /* open green or red&green led */
+	STATE_ALWAYS_ON = 3, /* keep green or red&green led always on */
+	STATE_ALL_OFF = 4,   /* close all led */
+};
+
+enum gpio_level {
+	LOW = 0,
+	HIGHT = 1,
+};
+
+struct led_gpio {
+	unsigned int pin;
+	enum gpio_level gpio_active;
+	enum led_type type;
+	struct led_gpio *next;
+};
+
+struct ledlight {
+	struct proc_dir_entry *leddir;
+	struct proc_dir_entry *netdir;
+	struct proc_dir_entry *powerdir;
+	struct led_gpio *net_gpio;
+	enum led_state net_state;
+	struct led_gpio *power_gpio;
+	enum led_state power_state;
+};
+
+static struct ledlight led_data;
+
+static int ledlight_count_gpio(struct led_gpio *gpio_list)
+{
+	int count = 0;
+	struct led_gpio *pre_gpio = NULL;
+
+	pre_gpio = gpio_list;
+	while (pre_gpio) {
+		count++;
+		pre_gpio = pre_gpio->next;
+	}
+
+	pr_info("%s, gpio count: %d\n", __func__, count);
+	return count;
+}
+
+static struct led_gpio *ledlight_find_gpio_by_type(
+		struct led_gpio *gpio_list, enum led_type type)
+{
+	struct led_gpio *pre_gpio = NULL;
+	pre_gpio = gpio_list;
+	while (pre_gpio) {
+		if (pre_gpio->type == type)
+			return pre_gpio;
+		pre_gpio = pre_gpio->next;
+	}
+	return NULL;
+}
+
+static int ledlight_add_to_list(
+		struct led_gpio **gpio_list, struct led_gpio *gpio)
+{
+	struct led_gpio *pre_gpio = NULL;
+
+	if (*gpio_list == NULL) {
+		*gpio_list = gpio;
+	} else {
+		pre_gpio = *gpio_list;
+		while (pre_gpio->next != NULL)
+			pre_gpio = pre_gpio->next;
+		pre_gpio->next = gpio;
+	}
+	return 0;
+}
+
+static int ledlight_free_list(struct led_gpio **gpio_list)
+{
+	struct led_gpio *pre_gpio = NULL;
+	pre_gpio = *gpio_list;
+	while (pre_gpio) {
+		*gpio_list = (*gpio_list)->next;
+		kfree(pre_gpio);
+		pre_gpio = *gpio_list;
+	}
+	return 0;
+}
+
+static int set_led(int pin, enum gpio_level level)
+{
+	if (pin < 0) {
+		pr_err("%s set fail, pin=%d\n", __func__, pin);
+		return 0;
+	}
+
+	pr_info("%s set pin: %d, level: %d\n", __func__, pin, level);
+	gpio_direction_output(pin, level);
+	return 0;
+}
+
+static int set_leds(enum led_state state, struct led_gpio *gpio_list)
+{
+	struct led_gpio *gpio_rg = NULL;
+	struct led_gpio *gpio_r = NULL;
+	struct led_gpio *gpio_g = NULL;
+
+	if (gpio_list == NULL) {
+		pr_err("%s gpio list is NULL!\n", __func__);
+		return -1;
+	}
+
+	gpio_rg = ledlight_find_gpio_by_type(gpio_list, LED_RG);
+	gpio_r = ledlight_find_gpio_by_type(gpio_list, LED_R);
+	gpio_g = ledlight_find_gpio_by_type(gpio_list, LED_G);
+
+	if (state == STATE_OFF) {
+		if (gpio_rg != NULL) {
+			set_led(gpio_rg->pin, !gpio_rg->gpio_active);
+		} else {
+			/* open led led */
+			if (gpio_r != NULL)
+				set_led(gpio_r->pin, gpio_r->gpio_active);
+			if (gpio_g != NULL)
+				set_led(gpio_g->pin, !gpio_g->gpio_active);
+		}
+	} else if ((state == STATE_ON) || (state == STATE_ALWAYS_ON)) {
+		if (gpio_rg != NULL) {
+			set_led(gpio_rg->pin, gpio_rg->gpio_active);
+		} else {
+			/* open green led */
+			if (gpio_r != NULL)
+				set_led(gpio_r->pin, !gpio_r->gpio_active);
+			if (gpio_g != NULL)
+				set_led(gpio_g->pin, gpio_g->gpio_active);
+		}
+	} else if (state == STATE_ALL_OFF) {
+		if (gpio_rg != NULL) {
+			set_led(gpio_rg->pin, !gpio_rg->gpio_active);
+		} else {
+			/* close led and green led */
+			if (gpio_r != NULL)
+				set_led(gpio_r->pin, !gpio_r->gpio_active);
+			if (gpio_g != NULL)
+				set_led(gpio_g->pin, !gpio_g->gpio_active);
+		}
+	} else {
+			pr_err("%s error, state is %d!\n", __func__, state);
+	}
+
+	return 0;
+}
+
+//by luobx
+int set_remote_leds(int state)
+{
+	struct led_gpio *gpio_r = NULL;
+	struct led_gpio *gpio_g = NULL;
+	int led_red_status = 1;
+
+	if (led_data.power_gpio == NULL) {
+		pr_err("%s gpio list is NULL!\n", __func__);
+		return -1;
+	}
+
+	gpio_r = ledlight_find_gpio_by_type(led_data.power_gpio, LED_R);
+	gpio_g = ledlight_find_gpio_by_type(led_data.power_gpio, LED_G);
+	
+	led_red_status = gpio_get_value(gpio_r->pin);
+	if(!led_red_status){
+		if (state){
+			set_led(gpio_g->pin, gpio_g->gpio_active);
+		}
+		else
+			set_led(gpio_g->pin, !gpio_g->gpio_active);
+	}	
+	return 0;
+}
+EXPORT_SYMBOL(set_remote_leds);
+
+static ssize_t netled_control(struct file *file, const char __user *buffer,
+		size_t size, loff_t *loff)
+{
+	char buf[128] = {0};
+	int ret = 0;
+
+	if (size > 0) {
+		memset(buf, 0, sizeof(buf));
+		ret = copy_from_user(buf, buffer, size);
+		if (ret != 0)
+			return -EINVAL;
+
+		if (strncmp(buf, "on", 2) == 0)
+			led_data.net_state = STATE_ON;
+		else if (strncmp(buf, "always_on", 9) == 0)
+			led_data.net_state = STATE_ALWAYS_ON;
+		else if (strncmp(buf, "off", 3) == 0)
+			led_data.net_state = STATE_OFF;
+		else if (strncmp(buf, "all_off", 6) == 0)
+			led_data.net_state = STATE_ALL_OFF;
+
+		set_leds(led_data.net_state, led_data.net_gpio);
+	}
+	return size;
+}
+
+static ssize_t powerled_control(struct file *file, const char __user *buffer,
+		size_t size, loff_t *loff)
+{
+	char buf[128] = {0};
+	int ret = 0;
+
+	if (size > 0) {
+		memset(buf, 0, sizeof(buf));
+		ret = copy_from_user(buf, buffer, size);
+		if (ret != 0)
+			return -EINVAL;
+
+		if (strncmp(buf, "on", 2) == 0)
+			led_data.power_state = STATE_ON;
+		else if (strncmp(buf, "off", 3) == 0)
+			led_data.power_state = STATE_OFF;
+		else if (strncmp(buf, "all_off", 6) == 0)
+			led_data.power_state = STATE_ALL_OFF;
+
+		set_leds(led_data.power_state, led_data.power_gpio);
+	}
+	return size;
+}
+
+static const struct file_operations netled_proc_fops = {
+	.write = netled_control,
+};
+
+static const struct file_operations powerled_proc_fops = {
+	.write = powerled_control,
+};
+
+static void init_led_data(void)
+{
+	led_data.leddir = NULL;
+	led_data.netdir = NULL;
+	led_data.powerdir = NULL;
+	led_data.net_gpio = NULL;
+	led_data.power_gpio = NULL;
+	led_data.net_state = STATE_OFF;
+	led_data.power_state = STATE_ON;
+}
+
+static void ledlight_suspend(struct early_suspend *h)
+{
+	pr_info("%s!\n", __func__);
+	if (led_data.netdir != NULL)
+		set_leds(STATE_ALL_OFF, led_data.net_gpio);
+
+	if (led_data.powerdir != NULL)
+		set_leds(STATE_OFF, led_data.power_gpio);
+}
+
+static void ledlight_resume(struct early_suspend *h)
+{
+	pr_info("%s!\n", __func__);
+	if (led_data.net_state == STATE_ALWAYS_ON) {
+		if (led_data.netdir != NULL)
+			set_leds(STATE_ALWAYS_ON, led_data.net_gpio);
+	}
+	if (led_data.powerdir != NULL)
+		set_leds(STATE_ON, led_data.power_gpio);
+}
+
+static int ledlight_gpio_parse_dt(struct device_node *node, int id)
+{
+	int ret =  -1;
+	unsigned int val;
+	const char *led_name = NULL;
+	const char *led_type = NULL;
+	struct gpio_desc *desc = NULL;
+	struct led_gpio *gpio = NULL;
+	enum ledlight_type type = LED_UNKNOWN;
+
+	gpio = kzalloc(sizeof(struct led_gpio), GFP_KERNEL);
+	if (!gpio) {
+		pr_err("%s:%d, no memory for led_gpio\n", __func__, __LINE__);
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	/* parser led name, for example <  led_name = "power_led"  > */
+	ret = of_property_read_string(node, "led_name", &led_name);
+	if (ret < 0) {
+		pr_err("%s:%d, get led_name fail\n", __func__, __LINE__);
+		ret = -EINVAL;
+		goto exit;
+	}
+	if (led_name) {
+		pr_info("led_name: %s\n", led_name);
+		if (strncmp(led_name, "net_led", 7) == 0)
+			type = LED_NET;
+		else if (strncmp(led_name, "power_led", 9) == 0)
+			type = LED_POWER;
+		else {
+			pr_err("%s:%d, not support this ledlight type(%s)\n",
+					__func__, __LINE__, led_name);
+			goto exit;
+		}
+	}
+
+	/* parser led gpio, for example
+		<  led_gpio = <&gpio_ao  GPIOAO_2  GPIO_ACTIVE_HIGH>  > */
+	desc = of_get_named_gpiod_flags(node, "led_gpio", 0, NULL);
+	if (IS_ERR(desc)) {
+		pr_err("%s:%d, get led_gpio fail\n", __func__, __LINE__);
+		ret = -EINVAL;
+		goto exit;
+	}
+	gpio->pin = desc_to_gpio(desc);
+	pr_info("gpio pin: %d\n", gpio->pin);
+	gpio_request(gpio->pin, DRV_NAME);
+
+	/* parser led_active, for example <  led_active = <1>  > */
+	ret = of_property_read_u32(node, "led_active", &val);
+	if (ret) {
+		pr_info("faild to get led_active\n");
+		/* set default active_low */
+		val = 1;
+	}
+	pr_info("gpio active: %d\n", val);
+	if (val == 1)
+		gpio->gpio_active = HIGHT;
+	else
+		gpio->gpio_active = LOW;
+
+	/* parser led_type, for example <  led_type = "R&G"  > */
+	ret = of_property_read_string(node, "led_type", &led_type);
+	if (ret < 0) {
+		pr_err("%s:%d,get led_type fail\n", __func__, __LINE__);
+		ret = -EINVAL;
+		goto exit;
+	}
+	if (led_type) {
+		pr_info("led_type: %s\n", led_type);
+		if (strncmp(led_type, "R&G", 3) == 0)
+			gpio->type = LED_RG;
+		else if (strncmp(led_type, "R", 1) == 0)
+			gpio->type = LED_R;
+		else if (strncmp(led_type, "G", 1) == 0)
+			gpio->type = LED_G;
+		else {
+			pr_err("%s:%d, not support this led type(%s)\n",
+					__func__, __LINE__, led_type);
+			goto exit;
+		}
+	}
+
+	if (type == LED_NET)
+		ledlight_add_to_list(&led_data.net_gpio, gpio);
+	else if (type == LED_POWER)
+		ledlight_add_to_list(&led_data.power_gpio, gpio);
+	else {
+		pr_err("%s:%d, not support this ledlight type(%d)\n",
+				__func__, __LINE__, type);
+		goto exit;
+	}
+	return 0;
+exit:
+	kfree(gpio);
+	return ret;
+}
+
+static int ledlight_item_create(struct platform_device *pdev)
+{
+	int ret =  -1;
+	int index;
+	struct device_node *child;
+	struct device_node *np = pdev->dev.of_node;
+
+	of_node_get(np);
+	index = 0;
+	for_each_child_of_node(np, child) {
+		ret = ledlight_gpio_parse_dt(child, index);
+		if (!ret)
+			index++;
+	}
+	pr_info("ledlight gpio-num is %d\n", index);
+	return 0;
+}
+
+static int ledlight_probe(struct platform_device *pdev)
+{
+	pr_info("%s!\n", __func__);
+	init_led_data();
+
+	led_data.leddir = proc_mkdir(DRV_NAME, NULL);
+	ledlight_item_create(pdev);
+
+	if (ledlight_count_gpio(led_data.net_gpio) > 0) {
+		set_leds(led_data.net_state, led_data.net_gpio);
+		led_data.netdir = proc_mkdir("netled", led_data.leddir);
+		proc_create_data("state", 0666, led_data.netdir,
+				&netled_proc_fops, NULL);
+	}
+	if (ledlight_count_gpio(led_data.power_gpio) > 0) {
+		set_leds(led_data.power_state, led_data.power_gpio);
+		led_data.powerdir = proc_mkdir("powerled", led_data.leddir);
+		proc_create_data("state", 0666, led_data.powerdir,
+				&powerled_proc_fops, NULL);
+	}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	ledlight_early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
+	ledlight_early_suspend.suspend = ledlight_suspend;
+	ledlight_early_suspend.resume = ledlight_resume;
+	register_early_suspend(&ledlight_early_suspend);
+#endif
+	return 0;
+}
+
+static int ledlight_remove(struct platform_device *pdev)
+{
+	pr_info("%s!\n", __func__);
+	ledlight_free_list(&led_data.net_gpio);
+	ledlight_free_list(&led_data.power_gpio);
+	if (led_data.netdir != NULL) {
+		remove_proc_entry("state", led_data.netdir);
+		if (led_data.leddir != NULL)
+			remove_proc_entry("netled", led_data.leddir);
+	}
+	if (led_data.powerdir != NULL) {
+		remove_proc_entry("state", led_data.powerdir);
+		if (led_data.leddir != NULL)
+			remove_proc_entry("powerled", led_data.leddir);
+	}
+	remove_proc_entry(DRV_NAME, NULL);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&ledlight_early_suspend);
+#endif
+	return 0;
+}
+
+static const struct of_device_id ledlight_dt_match[] = {
+	{	.compatible = "amlogic, ledlight", },
+	{},
+};
+
+static struct platform_driver ledlight_driver = {
+	.probe = ledlight_probe,
+	.remove = ledlight_remove,
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = ledlight_dt_match,
+	}
+};
+
+static int __init aml_ledlight_init(void)
+{
+	pr_info("%s!\n", __func__);
+	if (platform_driver_register(&ledlight_driver)) {
+		pr_err("failed to register ledlight driver\n");
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static void __exit aml_ledlight_exit(void)
+{
+	pr_info("%s!\n", __func__);
+	platform_driver_unregister(&ledlight_driver);
+}
+
+module_init(aml_ledlight_init);
+module_exit(aml_ledlight_exit);
+
+MODULE_DESCRIPTION("Amlogic ledlight driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Amlogic, Inc.");
+
-- 
2.7.4

